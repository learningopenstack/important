### 分布式存在的问题
  在集中式系统中，进行一个同步操作要写同一个数据的时候，可以直接使用**事务+锁**来管理保证数据的ACID。但是，在分布式系统中如何保证多台机器不会同时写同一条数据呢？
 
### Zookeeper
	Zookeeper是一个开放源码的分布式服务协调组件，是Google Chubby的开源实现。是一个高性能的分布式数据一致性解决方案。他将那些复杂的、容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并提供一系列简单易用的接口给用户使用。

### Zookeeper提供了哪些特性
	解决的分布式数据一致性问题，提供了顺序一致性、原子性、单一视图、可靠性、实时性等。
		- 顺序一致性：客户端的更新顺序与他们被发送的顺序相一致；
		- 原子性：更新操作要么全部成功，要么全部失败；
		- (隔离性)单一试图：无论客户端连接到哪一个服务器，都可以看到相同的ZooKeeper视图；
		- 可靠性：一旦一个更新操作被应用，那么在客户端再次更新它之前，其值将不会被改变；

### 幂等实现方案

在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。
但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。
如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。
但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。
所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。

### XA规范
	X/open（open group)定义了分布式事务处理模型。
		- 应用程序（AP）
		- 事务管理器（TM)	 - 常见的事务管理器（TM)是交易中间件
		- 资源管理器（RM）	- 常见的资源管理器是数据库
		- 通信资源管理器（CRM) - 常见的通信资源管理器是消息中间件
	 通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，
	 而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，
	 如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。一般情况下，某一数据库无法知道其它数据库在做什么，
	 因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。
```c++
	XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 
	XA 接口函数由数据库厂商提供。
```	
	 二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现XA分布式事务的关键。
	 (确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)
	 
	 二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
	 
	 准备阶段
事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，
写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。
可以进一步将准备阶段分为以下三个步骤：
	1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
	2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
	3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，
	则它返回一个”中止”消息。
	
	二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：	
		1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
		2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，
		那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。
		（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
		3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，
		这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。
		但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
		4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。
		那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
	 由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。
	 
	 3pc：
	 	1、引入超时机制。同时在协调者和参与者中都引入超时机制。
		2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
	也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。
		
	CanCommit阶段
		3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
		1.事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
		2、响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No
	precommit阶段
		协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。
	 	1、假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。
		2、发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
		3、事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
		4、响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。
	假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
		
	 
### 柔性事务
	相比较与数据库事务中的ACID这种刚性事务来说，柔性事务保证的事“基本可用，最终一致。”这其实就是基于BASE理论，保证数据的最终一致性。
	可查询操作，几乎是所有的分布式解决方案都需要的。

### TCC操作
	TCC 即 Try-Confirm-Cancel。

	
实时性：在特定的一段时间内，系统的任何变更都将被客户端检测到；

事务、锁、日志、二阶段提交
事务的四大特性(简称ACID)
MySQL数据库针对这四种特性，为我们提供的四种隔离级别，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
	- 更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。
	- 脏读：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。
	- 不可重读：事务A读取到了事务B已经提交的修改数据，不符合隔离性
	- 幻读：事务A读取到了事务B提交的新增数据，不符合隔离性

阿里沈询： 分布式事务原理与实践：
https://yq.aliyun.com/edu/lesson/play/508
单机事务：
事务的简介：
	（同步机制，针对共享数据的读写访问，多次读写访问的顺序）
	- 事务的核心是锁与并发
	- 性能较低

事务单元；

事务 ——　MVCC
本质上就是 copy on write
	- 能够做到写不阻塞读

事务的调优原则：
- 在不影响业务应用的前提下：
	- 减少锁的覆盖范围
		- myisam 表锁 -> innodb 行锁
		- 原位锁      -> mvcc多版本
- 增加锁上可并行的线程数
	- 读写锁分离，允许并行读取数据
- 选择正确锁类型
	- 悲观锁 适合并发争抢严重场景
	- 乐观锁（自旋锁） 适合并发争抢不严重的场景

事务的ACID


处理事务的常见方法：
	- 排队法
	- 排他锁
	- 读写锁
	- mvcc

https://yq.aliyun.com/articles/69211?spm=5176.8091938.0.0.KF8dRO


https://yq.aliyun.com/video/play/551?spm=a2c4e.11153940.blogcont69211.32.4c1267a2Z9m5oS

什么是事务：
	- 让很多步操作顺序发生；
	- 多进程/线程看上去就像是一步操作；

基于锁的事务实现中遇到的问题：
	- 从2PL到2PC
	- 分布式事务异常处理
	- 分布式日志记录
	- 分布式事务延迟变大问题

2Phase Lock（单机事务模式）
	BeginTrx：
		Read from Bob（lockBob）；
		Read from smith (locksmith)；
		Bob - 100
		Smith + 100
		Commit（unlockBob， unlockSmith）
如何扩展到分布式中呢？ 
	如果是A，B在两台不同机器上，如何提交呢？
	- 加锁、去锁操作的分布式系统化
	将Commit解锁的过程在多台机器上进行；
	-带来的问题：
		- 谁来负责这次跨机提交
		- 网络不可达怎么处理

2Phase Prepare
	
	prepare Bob  => 	Prepare Smith
	(lock Bob)			(lock Smith)

	该线程对Bob的一些操作， 该线程对Smith的一些操作

	Commit Bob    =>   	Commit Smith 
	(unlock Bob)		(unlock smith)

 问题出现在2次Commit 不能保证都成功；
 （Bob 提交成功之后， Smith提交呢）
 处理方式：
 	- 尽最大努力送达；一直重试，尽力让Smith也成功；
 	- 人工介入处理，
  还可以优化的点； Smith账户也是多份的呢（paxos协议）

 分布式事务的异常处理：
 	- 由第三者（协调者）负责跨机器提交
 	- Bob账户异常情况处理
 	- Smith账户异常处理
 随之带来的问题：
 	- 协调者如何保证高可用
 	- 参与者如何保证高可用

 协调者高可用：
 	-协调者必须是多机
 	- 任意协调者必须能够知道这个事务运行的状态
 		- 记录日志
 		- prepared 阶段只需要记录一次日志
 		- 每个节点的Commit都必须记录日志

 	日志：
 		BeginTrx:
 		Log XA-Trx begin;
 		Read from Bob(lockBob)
 		Read from Smith(lockSmith)
 		LogXA -prepared Bob, Smith
 		Bob - 100;
 		Smith + 100;
 		Commit(unlockBob, unlockSmith)
 		Log XA Commit Bob
 		Log XA Commit Smith

 	问题：
 		- 日志如何记录才能保证不丢（raft协议）
 		- 日志如何记录才能保证高可用

分布式事务延迟变大问题：
	操作指令				           耗时 		        	总耗时
	锁定Bob账户  		      	    0.001ms
	通过网络锁定Smith账户       2ms + 0.001ms
	查看Bob账户是否有100	        1ms
	从Bob账户中减去100	  	    2ms               11.004ms
	通过网络给Smith账户增加100   2ms + 2ms
	解锁Bob账户			          	0.001ms
	通过网络解锁Smith账户	      2ms + 0.001ms


结合MVCC的事务实现中遇到的问题
	- MVCC的顺序问题

http://yq.aliyun.com/webinar/play/185

常见分布式锁方案如下:
    - 基于数据库实现分布式锁
        - 基于数据库表
        - 基于数据库排他锁
    - 基于缓存，实现分布式锁，如redis
    - 基于Zookeeper实现分布式锁


